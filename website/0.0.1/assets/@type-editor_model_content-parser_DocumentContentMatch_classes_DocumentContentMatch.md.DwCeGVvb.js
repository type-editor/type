import{_ as s,o as t,c as e,ak as i}from"./chunks/framework.EVMbD_FN.js";const c=JSON.parse('{"title":"Class: DocumentContentMatch","description":"","frontmatter":{},"headers":[],"relativePath":"@type-editor/model/content-parser/DocumentContentMatch/classes/DocumentContentMatch.md","filePath":"@type-editor/model/content-parser/DocumentContentMatch/classes/DocumentContentMatch.md"}'),n={name:"@type-editor/model/content-parser/DocumentContentMatch/classes/DocumentContentMatch.md"};function h(l,a,r,p,o,k){return t(),e("div",null,[...a[0]||(a[0]=[i(`<p><a href="./../../../../../README.html"><strong>Type Editor</strong></a></p><hr><p><a href="./../../../../../">Type Editor</a> / <a href="./../../../README.html">@type-editor/model</a> / <a href="./../README.html">content-parser/DocumentContentMatch</a> / DocumentContentMatch</p><h1 id="class-documentcontentmatch" tabindex="-1">Class: DocumentContentMatch <a class="header-anchor" href="#class-documentcontentmatch" aria-label="Permalink to “Class: DocumentContentMatch”">​</a></h1><p>Defined in: <a href="https://github.com/type-editor/type/blob/a2760cc13c592972408bf3457981c13a24abf3a2/packages/model/src/content-parser/DocumentContentMatch.ts#L88" target="_blank" rel="noreferrer">packages/model/src/content-parser/DocumentContentMatch.ts:88</a></p><p>Instances of this class represent a match state of a node type&#39;s <a href="#model-nodespec-content">content expression</a>, and can be used to find out whether further content matches here, and whether a given position is a valid end of the node.</p><p>The content match system uses a finite automaton approach where each ContentMatch instance represents a state, and edges represent possible node types that can be matched at that state.</p><h2 id="finite-automaton-model" tabindex="-1">Finite Automaton Model <a class="header-anchor" href="#finite-automaton-model" aria-label="Permalink to “Finite Automaton Model”">​</a></h2><p>Content expressions (like &quot;paragraph+&quot; or &quot;heading | paragraph*&quot;) are compiled into a finite automaton where:</p><ul><li>Each state (ContentMatch) represents a position in parsing the expression</li><li>Edges represent valid node types that can appear at that position</li><li>Valid end states indicate where content can legally terminate</li></ul><h2 id="common-operations" tabindex="-1">Common Operations <a class="header-anchor" href="#common-operations" aria-label="Permalink to “Common Operations”">​</a></h2><ul><li><strong>Matching</strong>: Check if a node type or fragment can appear at this position</li><li><strong>Filling</strong>: Find what nodes to insert to make invalid content valid</li><li><strong>Wrapping</strong>: Find how to wrap a node to make it fit at this position</li><li><strong>Validation</strong>: Check if content satisfies the content expression</li></ul><h2 id="example" tabindex="-1">Example <a class="header-anchor" href="#example" aria-label="Permalink to “Example”">​</a></h2><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Check if a paragraph can appear at this position</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nextMatch</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> contentMatch.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">matchType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(schema.nodes.paragraph);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (nextMatch) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Paragraph is valid here&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Fill before a fragment to make it valid</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> toInsert</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> contentMatch.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fillBefore</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(fragment);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (toInsert) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // Insert these nodes before the fragment</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Find wrapping for a node</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> wrapping</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> contentMatch.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">findWrapping</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(schema.nodes.list_item);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (wrapping) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // Wrap the node in these node types (outermost first)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="implements" tabindex="-1">Implements <a class="header-anchor" href="#implements" aria-label="Permalink to “Implements”">​</a></h2><ul><li><a href="./../../../types/content-parser/ContentMatch/interfaces/ContentMatch.html"><code>ContentMatch</code></a></li></ul><h2 id="constructors" tabindex="-1">Constructors <a class="header-anchor" href="#constructors" aria-label="Permalink to “Constructors”">​</a></h2><h3 id="constructor" tabindex="-1">Constructor <a class="header-anchor" href="#constructor" aria-label="Permalink to “Constructor”">​</a></h3><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> DocumentContentMatch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(validEnd): DocumentContentMatch;</span></span></code></pre></div><p>Defined in: <a href="https://github.com/type-editor/type/blob/a2760cc13c592972408bf3457981c13a24abf3a2/packages/model/src/content-parser/DocumentContentMatch.ts#L134" target="_blank" rel="noreferrer">packages/model/src/content-parser/DocumentContentMatch.ts:134</a></p><p>Creates a new content match state.</p><p>ContentMatch instances are typically created during schema compilation when content expressions are parsed into finite automaton states. Direct construction is rarely needed in user code.</p><h4 id="parameters" tabindex="-1">Parameters <a class="header-anchor" href="#parameters" aria-label="Permalink to “Parameters”">​</a></h4><table tabindex="0"><thead><tr><th>Parameter</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>validEnd</code></td><td><code>boolean</code></td><td>Whether this match state represents a valid end of the node. True means content can legally terminate at this state.</td></tr></tbody></table><h4 id="returns" tabindex="-1">Returns <a class="header-anchor" href="#returns" aria-label="Permalink to “Returns”">​</a></h4><p><code>DocumentContentMatch</code></p><h4 id="example-1" tabindex="-1">Example <a class="header-anchor" href="#example-1" aria-label="Permalink to “Example”">​</a></h4><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// A valid end state (content can stop here)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> endState</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ContentMatch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// An intermediate state (more content required)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> intermediateState</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ContentMatch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><h2 id="accessors" tabindex="-1">Accessors <a class="header-anchor" href="#accessors" aria-label="Permalink to “Accessors”">​</a></h2><h3 id="defaulttype" tabindex="-1">defaultType <a class="header-anchor" href="#defaulttype" aria-label="Permalink to “defaultType”">​</a></h3><h4 id="get-signature" tabindex="-1">Get Signature <a class="header-anchor" href="#get-signature" aria-label="Permalink to “Get Signature”">​</a></h4><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">get </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">defaultType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): NodeType;</span></span></code></pre></div><p>Defined in: <a href="https://github.com/type-editor/type/blob/a2760cc13c592972408bf3457981c13a24abf3a2/packages/model/src/content-parser/DocumentContentMatch.ts#L227" target="_blank" rel="noreferrer">packages/model/src/content-parser/DocumentContentMatch.ts:227</a></p><p>Get the first matching node type at this match position that can be generated without additional attributes or content.</p><p>This is useful for automatically filling content. It returns the first node type that:</p><ul><li>Is not a text node (text requires actual text content)</li><li>Doesn&#39;t have required attributes (would need attribute values)</li></ul><p>Returns null if no such &quot;fillable&quot; type exists at this position.</p><h5 id="example-2" tabindex="-1">Example <a class="header-anchor" href="#example-2" aria-label="Permalink to “Example”">​</a></h5><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> defaultType</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> contentMatch.defaultType;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (defaultType) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // Can auto-fill with this type</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> node</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> defaultType.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createAndFill</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h5 id="returns-1" tabindex="-1">Returns <a class="header-anchor" href="#returns-1" aria-label="Permalink to “Returns”">​</a></h5><p><a href="./../../../schema/NodeType/classes/NodeType.html"><code>NodeType</code></a></p><p>The first auto-fillable node type, or null if none exists.</p><h4 id="implementation-of" tabindex="-1">Implementation of <a class="header-anchor" href="#implementation-of" aria-label="Permalink to “Implementation of”">​</a></h4><p><a href="./../../../types/content-parser/ContentMatch/interfaces/ContentMatch.html"><code>ContentMatch</code></a>.<a href="./../../../types/content-parser/ContentMatch/interfaces/ContentMatch.html#property-defaulttype"><code>defaultType</code></a></p><hr><h3 id="edgecount" tabindex="-1">edgeCount <a class="header-anchor" href="#edgecount" aria-label="Permalink to “edgeCount”">​</a></h3><h4 id="get-signature-1" tabindex="-1">Get Signature <a class="header-anchor" href="#get-signature-1" aria-label="Permalink to “Get Signature”">​</a></h4><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">get </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">edgeCount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): number;</span></span></code></pre></div><p>Defined in: <a href="https://github.com/type-editor/type/blob/a2760cc13c592972408bf3457981c13a24abf3a2/packages/model/src/content-parser/DocumentContentMatch.ts#L256" target="_blank" rel="noreferrer">packages/model/src/content-parser/DocumentContentMatch.ts:256</a></p><p>The number of outgoing edges this node has in the finite automaton that describes the content expression.</p><p>This indicates how many different node types can validly appear at this position. An edgeCount of 0 means no content can follow (though this might still be a valid end state).</p><h5 id="example-3" tabindex="-1">Example <a class="header-anchor" href="#example-3" aria-label="Permalink to “Example”">​</a></h5><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`\${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">contentMatch</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">edgeCount</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">} possible node types here\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (contentMatch.edgeCount </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;&amp;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> !</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">contentMatch.validEnd) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Invalid state - no content allowed but not an end&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h5 id="returns-2" tabindex="-1">Returns <a class="header-anchor" href="#returns-2" aria-label="Permalink to “Returns”">​</a></h5><p><code>number</code></p><p>The number of possible next node types.</p><h4 id="implementation-of-1" tabindex="-1">Implementation of <a class="header-anchor" href="#implementation-of-1" aria-label="Permalink to “Implementation of”">​</a></h4><p><a href="./../../../types/content-parser/ContentMatch/interfaces/ContentMatch.html"><code>ContentMatch</code></a>.<a href="./../../../types/content-parser/ContentMatch/interfaces/ContentMatch.html#property-edgecount"><code>edgeCount</code></a></p><hr><h3 id="inlinecontent" tabindex="-1">inlineContent <a class="header-anchor" href="#inlinecontent" aria-label="Permalink to “inlineContent”">​</a></h3><h4 id="get-signature-2" tabindex="-1">Get Signature <a class="header-anchor" href="#get-signature-2" aria-label="Permalink to “Get Signature”">​</a></h4><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">get </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">inlineContent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): boolean;</span></span></code></pre></div><p>Defined in: <a href="https://github.com/type-editor/type/blob/a2760cc13c592972408bf3457981c13a24abf3a2/packages/model/src/content-parser/DocumentContentMatch.ts#L201" target="_blank" rel="noreferrer">packages/model/src/content-parser/DocumentContentMatch.ts:201</a></p><p>Returns true if this match state represents inline content. Content is considered inline if there are possible next matches and the first one is an inline node type.</p><p>This is used to distinguish between block-level and inline content contexts. For example, a paragraph&#39;s content match would have inlineContent = true, while a document&#39;s content match would have inlineContent = false.</p><h5 id="example-4" tabindex="-1">Example <a class="header-anchor" href="#example-4" aria-label="Permalink to “Example”">​</a></h5><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (contentMatch.inlineContent) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Expecting inline content like text or marks&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Expecting block-level content like paragraphs&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h5 id="returns-3" tabindex="-1">Returns <a class="header-anchor" href="#returns-3" aria-label="Permalink to “Returns”">​</a></h5><p><code>boolean</code></p><p>True if the next possible content is inline, false otherwise.</p><h4 id="implementation-of-2" tabindex="-1">Implementation of <a class="header-anchor" href="#implementation-of-2" aria-label="Permalink to “Implementation of”">​</a></h4><p><a href="./../../../types/content-parser/ContentMatch/interfaces/ContentMatch.html"><code>ContentMatch</code></a>.<a href="./../../../types/content-parser/ContentMatch/interfaces/ContentMatch.html#property-inlinecontent"><code>inlineContent</code></a></p><hr><h3 id="next" tabindex="-1">next <a class="header-anchor" href="#next" aria-label="Permalink to “next”">​</a></h3><h4 id="get-signature-3" tabindex="-1">Get Signature <a class="header-anchor" href="#get-signature-3" aria-label="Permalink to “Get Signature”">​</a></h4><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">get </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): MatchEdge[];</span></span></code></pre></div><p>Defined in: <a href="https://github.com/type-editor/type/blob/a2760cc13c592972408bf3457981c13a24abf3a2/packages/model/src/content-parser/DocumentContentMatch.ts#L154" target="_blank" rel="noreferrer">packages/model/src/content-parser/DocumentContentMatch.ts:154</a></p><p>Get the array of possible next match edges from this state.</p><p>Each edge represents a valid node type that can appear at this position, along with the state to transition to after matching that type.</p><h5 id="example-5" tabindex="-1">Example <a class="header-anchor" href="#example-5" aria-label="Permalink to “Example”">​</a></h5><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Explore all possible next node types</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> edge</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> of</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> contentMatch.next) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`Can accept: \${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">edge</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">type</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">name</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h5 id="returns-4" tabindex="-1">Returns <a class="header-anchor" href="#returns-4" aria-label="Permalink to “Returns”">​</a></h5><p><a href="./../../../types/content-parser/ContentMatch/interfaces/MatchEdge.html"><code>MatchEdge</code></a>[]</p><p>An array of match edges representing all valid transitions from this state.</p><h4 id="implementation-of-3" tabindex="-1">Implementation of <a class="header-anchor" href="#implementation-of-3" aria-label="Permalink to “Implementation of”">​</a></h4><p><a href="./../../../types/content-parser/ContentMatch/interfaces/ContentMatch.html"><code>ContentMatch</code></a>.<a href="./../../../types/content-parser/ContentMatch/interfaces/ContentMatch.html#property-next"><code>next</code></a></p><hr><h3 id="validend" tabindex="-1">validEnd <a class="header-anchor" href="#validend" aria-label="Permalink to “validEnd”">​</a></h3><h4 id="get-signature-4" tabindex="-1">Get Signature <a class="header-anchor" href="#get-signature-4" aria-label="Permalink to “Get Signature”">​</a></h4><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">get </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">validEnd</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): boolean;</span></span></code></pre></div><p>Defined in: <a href="https://github.com/type-editor/type/blob/a2760cc13c592972408bf3457981c13a24abf3a2/packages/model/src/content-parser/DocumentContentMatch.ts#L177" target="_blank" rel="noreferrer">packages/model/src/content-parser/DocumentContentMatch.ts:177</a></p><p>Returns true when this match state represents a valid end of the node.</p><p>When true, content can legally terminate at this state according to the content expression. For example, in &quot;paragraph+&quot;, after matching at least one paragraph, subsequent states are valid ends. In &quot;paragraph*&quot;, even the initial state is a valid end (zero or more paragraphs).</p><h5 id="example-6" tabindex="-1">Example <a class="header-anchor" href="#example-6" aria-label="Permalink to “Example”">​</a></h5><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (contentMatch.validEnd) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Content can legally end here&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;More content required&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h5 id="returns-5" tabindex="-1">Returns <a class="header-anchor" href="#returns-5" aria-label="Permalink to “Returns”">​</a></h5><p><code>boolean</code></p><p>True if content can terminate at this state, false otherwise.</p><h4 id="implementation-of-4" tabindex="-1">Implementation of <a class="header-anchor" href="#implementation-of-4" aria-label="Permalink to “Implementation of”">​</a></h4><p><a href="./../../../types/content-parser/ContentMatch/interfaces/ContentMatch.html"><code>ContentMatch</code></a>.<a href="./../../../types/content-parser/ContentMatch/interfaces/ContentMatch.html#property-validend"><code>validEnd</code></a></p><h2 id="methods" tabindex="-1">Methods <a class="header-anchor" href="#methods" aria-label="Permalink to “Methods”">​</a></h2><h3 id="compatible" tabindex="-1">compatible() <a class="header-anchor" href="#compatible" aria-label="Permalink to “compatible()”">​</a></h3><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">compatible</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(other): boolean;</span></span></code></pre></div><p>Defined in: <a href="https://github.com/type-editor/type/blob/a2760cc13c592972408bf3457981c13a24abf3a2/packages/model/src/content-parser/DocumentContentMatch.ts#L358" target="_blank" rel="noreferrer">packages/model/src/content-parser/DocumentContentMatch.ts:358</a></p><p>Check whether this match state is compatible with another match state. Two match states are compatible if they have at least one node type in common among their possible next matches.</p><p>This is useful when trying to join or merge content from different contexts. If two positions have compatible content matches, they can potentially accept the same type of content.</p><h4 id="parameters-1" tabindex="-1">Parameters <a class="header-anchor" href="#parameters-1" aria-label="Permalink to “Parameters”">​</a></h4><table tabindex="0"><thead><tr><th>Parameter</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>other</code></td><td><a href="./../../../types/content-parser/ContentMatch/interfaces/ContentMatch.html"><code>ContentMatch</code></a></td><td>The other content match state to check compatibility with.</td></tr></tbody></table><h4 id="returns-6" tabindex="-1">Returns <a class="header-anchor" href="#returns-6" aria-label="Permalink to “Returns”">​</a></h4><p><code>boolean</code></p><p>True if the match states share at least one common node type in their next possible matches, false if they have no node types in common.</p><h4 id="example-7" tabindex="-1">Example <a class="header-anchor" href="#example-7" aria-label="Permalink to “Example”">​</a></h4><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> match1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> schema.nodes.doc.contentMatch;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> match2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> schema.nodes.blockquote.contentMatch;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (match1.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">compatible</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(match2)) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Both can accept some common node type&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // e.g., both might accept paragraphs</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h4 id="implementation-of-5" tabindex="-1">Implementation of <a class="header-anchor" href="#implementation-of-5" aria-label="Permalink to “Implementation of”">​</a></h4><p><a href="./../../../types/content-parser/ContentMatch/interfaces/ContentMatch.html"><code>ContentMatch</code></a>.<a href="./../../../types/content-parser/ContentMatch/interfaces/ContentMatch.html#compatible"><code>compatible</code></a></p><hr><h3 id="edge" tabindex="-1">edge() <a class="header-anchor" href="#edge" aria-label="Permalink to “edge()”">​</a></h3><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">edge</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(number): MatchEdge;</span></span></code></pre></div><p>Defined in: <a href="https://github.com/type-editor/type/blob/a2760cc13c592972408bf3457981c13a24abf3a2/packages/model/src/content-parser/DocumentContentMatch.ts#L519" target="_blank" rel="noreferrer">packages/model/src/content-parser/DocumentContentMatch.ts:519</a></p><p>Get the <em>n</em>&#39;th outgoing edge from this node in the finite automaton that describes the content expression.</p><p>This provides indexed access to the edges, which can be useful when iterating through possible transitions numerically rather than using the <code>next</code> array directly.</p><h4 id="parameters-2" tabindex="-1">Parameters <a class="header-anchor" href="#parameters-2" aria-label="Permalink to “Parameters”">​</a></h4><table tabindex="0"><thead><tr><th>Parameter</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>number</code></td><td><code>number</code></td><td>The index of the edge to retrieve (0-based). Must be within the range [0, edgeCount).</td></tr></tbody></table><h4 id="returns-7" tabindex="-1">Returns <a class="header-anchor" href="#returns-7" aria-label="Permalink to “Returns”">​</a></h4><p><a href="./../../../types/content-parser/ContentMatch/interfaces/MatchEdge.html"><code>MatchEdge</code></a></p><p>The match edge at the specified index, containing the node type and next state.</p><h4 id="throws" tabindex="-1">Throws <a class="header-anchor" href="#throws" aria-label="Permalink to “Throws”">​</a></h4><p>If the index is out of bounds (negative or &gt;= edgeCount).</p><h4 id="example-8" tabindex="-1">Example <a class="header-anchor" href="#example-8" aria-label="Permalink to “Example”">​</a></h4><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> contentMatch.edgeCount; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> edge</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> contentMatch.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">edge</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(i);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`Edge \${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">i</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}: \${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">edge</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">type</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">name</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h4 id="implementation-of-6" tabindex="-1">Implementation of <a class="header-anchor" href="#implementation-of-6" aria-label="Permalink to “Implementation of”">​</a></h4><p><a href="./../../../types/content-parser/ContentMatch/interfaces/ContentMatch.html"><code>ContentMatch</code></a>.<a href="./../../../types/content-parser/ContentMatch/interfaces/ContentMatch.html#edge"><code>edge</code></a></p><hr><h3 id="fillbefore" tabindex="-1">fillBefore() <a class="header-anchor" href="#fillbefore" aria-label="Permalink to “fillBefore()”">​</a></h3><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fillBefore</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   after,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   toEnd</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   startIndex</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Fragment;</span></span></code></pre></div><p>Defined in: <a href="https://github.com/type-editor/type/blob/a2760cc13c592972408bf3457981c13a24abf3a2/packages/model/src/content-parser/DocumentContentMatch.ts#L414" target="_blank" rel="noreferrer">packages/model/src/content-parser/DocumentContentMatch.ts:414</a></p><p>Try to match the given fragment, and if that fails, see if it can be made to match by inserting nodes in front of it. When successful, return a fragment of inserted nodes (which may be empty if nothing had to be inserted). When <code>toEnd</code> is true, only return a fragment if the resulting match goes to the end of the content expression.</p><p>This method performs a depth-first search through possible node insertions to find a valid sequence that would allow the given fragment to match. It automatically creates and fills nodes using their default content.</p><p>The search avoids cycles by tracking visited states and only considers node types that don&#39;t require attributes or content (non-text, no required attrs).</p><h4 id="parameters-3" tabindex="-1">Parameters <a class="header-anchor" href="#parameters-3" aria-label="Permalink to “Parameters”">​</a></h4><table tabindex="0"><thead><tr><th>Parameter</th><th>Type</th><th>Default value</th><th>Description</th></tr></thead><tbody><tr><td><code>after</code></td><td><a href="./../../../elements/Fragment/classes/Fragment.html"><code>Fragment</code></a></td><td><code>undefined</code></td><td>The fragment that should match after inserting nodes. The method tries to find nodes to insert before this fragment to make the entire sequence valid.</td></tr><tr><td><code>toEnd</code></td><td><code>boolean</code></td><td><code>false</code></td><td>Whether the match must reach a valid end state. When true, only returns a result if content can legally end after the fragment. Default is false, allowing intermediate (non-terminal) states.</td></tr><tr><td><code>startIndex</code></td><td><code>number</code></td><td><code>0</code></td><td>The index in the fragment to start matching from. Allows matching a suffix of the fragment. Default is 0.</td></tr></tbody></table><h4 id="returns-8" tabindex="-1">Returns <a class="header-anchor" href="#returns-8" aria-label="Permalink to “Returns”">​</a></h4><p><a href="./../../../elements/Fragment/classes/Fragment.html"><code>Fragment</code></a></p><p>A fragment of nodes to insert before <code>after</code>, which may be empty if <code>after</code> already matches without insertions, or null if no valid insertion sequence exists.</p><h4 id="example-9" tabindex="-1">Example <a class="header-anchor" href="#example-9" aria-label="Permalink to “Example”">​</a></h4><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Try to make a fragment valid by inserting nodes before it</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> fragment</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Fragment.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([textNode]);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> toInsert</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> contentMatch.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fillBefore</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(fragment);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (toInsert) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // Combine: toInsert + fragment</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> validContent</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> toInsert.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">append</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(fragment);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Require reaching a valid end</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> toEnd</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> contentMatch.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fillBefore</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(fragment, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (toEnd </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> contentMatch.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">matchFragment</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(toEnd.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">append</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(fragment))?.validEnd) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Content is now complete&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h4 id="implementation-of-7" tabindex="-1">Implementation of <a class="header-anchor" href="#implementation-of-7" aria-label="Permalink to “Implementation of”">​</a></h4><p><a href="./../../../types/content-parser/ContentMatch/interfaces/ContentMatch.html"><code>ContentMatch</code></a>.<a href="./../../../types/content-parser/ContentMatch/interfaces/ContentMatch.html#fillbefore"><code>fillBefore</code></a></p><hr><h3 id="findwrapping" tabindex="-1">findWrapping() <a class="header-anchor" href="#findwrapping" aria-label="Permalink to “findWrapping()”">​</a></h3><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">findWrapping</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(target): readonly NodeType[];</span></span></code></pre></div><p>Defined in: <a href="https://github.com/type-editor/type/blob/a2760cc13c592972408bf3457981c13a24abf3a2/packages/model/src/content-parser/DocumentContentMatch.ts#L485" target="_blank" rel="noreferrer">packages/model/src/content-parser/DocumentContentMatch.ts:485</a></p><p>Find a set of wrapping node types that would allow a node of the given type to appear at this position. The result may be empty (when it fits directly) and will be null when no such wrapping exists.</p><p>This method uses breadth-first search to find the shortest wrapping sequence. For example, if a list_item can&#39;t appear directly in a doc, this might return [bullet_list] to indicate the list_item should be wrapped in a bullet_list.</p><p>The result is cached to avoid recomputing wrappings for the same target type, providing O(1) lookups after the first computation.</p><h4 id="parameters-4" tabindex="-1">Parameters <a class="header-anchor" href="#parameters-4" aria-label="Permalink to “Parameters”">​</a></h4><table tabindex="0"><thead><tr><th>Parameter</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>target</code></td><td><a href="./../../../schema/NodeType/classes/NodeType.html"><code>NodeType</code></a></td><td>The node type to find wrapping for. This is the innermost node type that needs to fit at the current position.</td></tr></tbody></table><h4 id="returns-9" tabindex="-1">Returns <a class="header-anchor" href="#returns-9" aria-label="Permalink to “Returns”">​</a></h4><p>readonly <a href="./../../../schema/NodeType/classes/NodeType.html"><code>NodeType</code></a>[]</p><p>An array of node types to wrap with (from outermost to innermost), an empty array if the target fits directly without wrapping, or null if no valid wrapping exists.</p><h4 id="example-10" tabindex="-1">Example <a class="header-anchor" href="#example-10" aria-label="Permalink to “Example”">​</a></h4><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Find how to wrap a list_item to fit in a doc</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> wrapping</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> docContentMatch.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">findWrapping</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(schema.nodes.list_item);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (wrapping) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // wrapping might be [bullet_list]</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // So we&#39;d wrap: bullet_list(list_item(...))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;Wrap in:&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    wrapping.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> t.name),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  );</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Empty array means no wrapping needed</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> direct</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> match.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">findWrapping</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(schema.nodes.paragraph);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (direct </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> direct.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Paragraph fits directly&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h4 id="implementation-of-8" tabindex="-1">Implementation of <a class="header-anchor" href="#implementation-of-8" aria-label="Permalink to “Implementation of”">​</a></h4><p><a href="./../../../types/content-parser/ContentMatch/interfaces/ContentMatch.html"><code>ContentMatch</code></a>.<a href="./../../../types/content-parser/ContentMatch/interfaces/ContentMatch.html#findwrapping"><code>findWrapping</code></a></p><hr><h3 id="matchfragment" tabindex="-1">matchFragment() <a class="header-anchor" href="#matchfragment" aria-label="Permalink to “matchFragment()”">​</a></h3><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">matchFragment</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   fragment,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   start</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   end</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ContentMatch;</span></span></code></pre></div><p>Defined in: <a href="https://github.com/type-editor/type/blob/a2760cc13c592972408bf3457981c13a24abf3a2/packages/model/src/content-parser/DocumentContentMatch.ts#L328" target="_blank" rel="noreferrer">packages/model/src/content-parser/DocumentContentMatch.ts:328</a></p><p>Try to match a fragment. Returns the resulting match state when successful.</p><p>Iterates through the child nodes in the fragment and attempts to match each one sequentially using matchType(). If any match fails, returns null immediately. This is essentially a fold operation over the fragment using matchType.</p><h4 id="parameters-5" tabindex="-1">Parameters <a class="header-anchor" href="#parameters-5" aria-label="Permalink to “Parameters”">​</a></h4><table tabindex="0"><thead><tr><th>Parameter</th><th>Type</th><th>Default value</th><th>Description</th></tr></thead><tbody><tr><td><code>fragment</code></td><td><a href="./../../../elements/Fragment/classes/Fragment.html"><code>Fragment</code></a></td><td><code>undefined</code></td><td>The fragment containing nodes to match. Each child node&#39;s type is matched sequentially from start to end.</td></tr><tr><td><code>start</code></td><td><code>number</code></td><td><code>0</code></td><td>The starting index in the fragment (inclusive). Defaults to 0.</td></tr><tr><td><code>end</code></td><td><code>number</code></td><td><code>fragment.childCount</code></td><td>The ending index in the fragment (exclusive). Defaults to the total number of children in the fragment.</td></tr></tbody></table><h4 id="returns-10" tabindex="-1">Returns <a class="header-anchor" href="#returns-10" aria-label="Permalink to “Returns”">​</a></h4><p><a href="./../../../types/content-parser/ContentMatch/interfaces/ContentMatch.html"><code>ContentMatch</code></a></p><p>The resulting content match state after matching all nodes in the range, or null if matching fails for any node in the sequence.</p><h4 id="example-11" tabindex="-1">Example <a class="header-anchor" href="#example-11" aria-label="Permalink to “Example”">​</a></h4><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> fragment</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Fragment.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([para1, para2, para3]);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Match the entire fragment</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> result</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> contentMatch.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">matchFragment</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(fragment);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (result) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Fragment is valid&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (result.validEnd) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;And can end here&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Match a sub-range</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> partial</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> contentMatch.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">matchFragment</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(fragment, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Only matches para2</span></span></code></pre></div><h4 id="implementation-of-9" tabindex="-1">Implementation of <a class="header-anchor" href="#implementation-of-9" aria-label="Permalink to “Implementation of”">​</a></h4><p><a href="./../../../types/content-parser/ContentMatch/interfaces/ContentMatch.html"><code>ContentMatch</code></a>.<a href="./../../../types/content-parser/ContentMatch/interfaces/ContentMatch.html#matchfragment"><code>matchFragment</code></a></p><hr><h3 id="matchtype" tabindex="-1">matchType() <a class="header-anchor" href="#matchtype" aria-label="Permalink to “matchType()”">​</a></h3><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">matchType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type): ContentMatch;</span></span></code></pre></div><p>Defined in: <a href="https://github.com/type-editor/type/blob/a2760cc13c592972408bf3457981c13a24abf3a2/packages/model/src/content-parser/DocumentContentMatch.ts#L286" target="_blank" rel="noreferrer">packages/model/src/content-parser/DocumentContentMatch.ts:286</a></p><p>Match a node type, returning the next match state after that node if successful.</p><p>This is the fundamental operation in the content matching automaton. It checks if the given node type is valid at the current position (i.e., if there&#39;s an outgoing edge for this type) and returns the next state if so.</p><h4 id="parameters-6" tabindex="-1">Parameters <a class="header-anchor" href="#parameters-6" aria-label="Permalink to “Parameters”">​</a></h4><table tabindex="0"><thead><tr><th>Parameter</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>type</code></td><td><a href="./../../../schema/NodeType/classes/NodeType.html"><code>NodeType</code></a></td><td>The node type to match. This is checked against all outgoing edges from the current state.</td></tr></tbody></table><h4 id="returns-11" tabindex="-1">Returns <a class="header-anchor" href="#returns-11" aria-label="Permalink to “Returns”">​</a></h4><p><a href="./../../../types/content-parser/ContentMatch/interfaces/ContentMatch.html"><code>ContentMatch</code></a></p><p>The next content match state if the type is valid at this position, or null if the node type is not allowed here.</p><h4 id="example-12" tabindex="-1">Example <a class="header-anchor" href="#example-12" aria-label="Permalink to “Example”">​</a></h4><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> match</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nodeType.contentMatch;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Check if paragraph is valid</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> afterPara</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> match.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">matchType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(schema.nodes.paragraph);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (afterPara) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Paragraph accepted&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // Can we add another paragraph?</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> afterTwo</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> afterPara.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">matchType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(schema.nodes.paragraph);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h4 id="implementation-of-10" tabindex="-1">Implementation of <a class="header-anchor" href="#implementation-of-10" aria-label="Permalink to “Implementation of”">​</a></h4><p><a href="./../../../types/content-parser/ContentMatch/interfaces/ContentMatch.html"><code>ContentMatch</code></a>.<a href="./../../../types/content-parser/ContentMatch/interfaces/ContentMatch.html#matchtype"><code>matchType</code></a></p><hr><h3 id="tostring" tabindex="-1">toString() <a class="header-anchor" href="#tostring" aria-label="Permalink to “toString()”">​</a></h3><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): string;</span></span></code></pre></div><p>Defined in: <a href="https://github.com/type-editor/type/blob/a2760cc13c592972408bf3457981c13a24abf3a2/packages/model/src/content-parser/DocumentContentMatch.ts#L552" target="_blank" rel="noreferrer">packages/model/src/content-parser/DocumentContentMatch.ts:552</a></p><p>Generate a string representation of this content match and all reachable states. Useful for debugging and visualizing the finite automaton structure.</p><p>The output format shows each state on a line with:</p><ul><li>State index (numbered from 0)</li><li>&#39;*&#39; marker if the state is a valid end</li><li>List of transitions: &quot;type-&gt;targetState&quot; pairs</li></ul><p>This performs a depth-first scan to discover all reachable states.</p><h4 id="returns-12" tabindex="-1">Returns <a class="header-anchor" href="#returns-12" aria-label="Permalink to “Returns”">​</a></h4><p><code>string</code></p><p>A multi-line string showing all states and their transitions.</p><h4 id="example-13" tabindex="-1">Example <a class="header-anchor" href="#example-13" aria-label="Permalink to “Example”">​</a></h4><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(contentMatch.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Output might be:</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 0  paragraph-&gt;1, heading-&gt;1</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 1* paragraph-&gt;1</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// State 0 can accept paragraph or heading, both go to state 1</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// State 1 is a valid end (*) and can accept more paragraphs</span></span></code></pre></div><h4 id="implementation-of-11" tabindex="-1">Implementation of <a class="header-anchor" href="#implementation-of-11" aria-label="Permalink to “Implementation of”">​</a></h4><p><a href="./../../../types/content-parser/ContentMatch/interfaces/ContentMatch.html"><code>ContentMatch</code></a>.<a href="./../../../types/content-parser/ContentMatch/interfaces/ContentMatch.html#tostring"><code>toString</code></a></p>`,209)])])}const g=s(n,[["render",h]]);export{c as __pageData,g as default};
