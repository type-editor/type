import{_ as e,o as a,c as i,ak as t}from"./chunks/framework.EVMbD_FN.js";const k=JSON.parse('{"title":"Class: DOMParser","description":"","frontmatter":{},"headers":[],"relativePath":"@type-editor/model/dom-parser/DOMParser/classes/DOMParser.md","filePath":"@type-editor/model/dom-parser/DOMParser/classes/DOMParser.md"}'),r={name:"@type-editor/model/dom-parser/DOMParser/classes/DOMParser.md"};function n(h,s,l,p,d,o){return a(),i("div",null,[...s[0]||(s[0]=[t(`<p><a href="./../../../../../README.html"><strong>Type Editor</strong></a></p><hr><p><a href="./../../../../../">Type Editor</a> / <a href="./../../../README.html">@type-editor/model</a> / <a href="./../README.html">dom-parser/DOMParser</a> / DOMParser</p><h1 id="class-domparser" tabindex="-1">Class: DOMParser <a class="header-anchor" href="#class-domparser" aria-label="Permalink to “Class: DOMParser”">​</a></h1><p>Defined in: <a href="https://github.com/type-editor/type/blob/29c0b7ebbb68b1528c0edc5e9973c4538cccdb64/packages/model/src/dom-parser/DOMParser.ts#L39" target="_blank" rel="noreferrer">packages/model/src/dom-parser/DOMParser.ts:39</a></p><p>A DOM parser represents a strategy for parsing DOM content into a ProseMirror document conforming to a given schema. Its behavior is defined by an array of <a href="#model-parserule">rules</a>.</p><p>The parser processes DOM nodes and converts them into ProseMirror document nodes based on the configured parse rules. It supports both tag-based rules (matching DOM elements by selector) and style-based rules (matching CSS properties).</p><h2 id="example" tabindex="-1">Example <a class="header-anchor" href="#example" aria-label="Permalink to “Example”">​</a></h2><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Create a parser from a schema</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> parser</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> DOMParser.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fromSchema</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(mySchema);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Parse a DOM element</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> doc</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> parser.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">parse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(domElement);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Parse a slice (for partial content)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> slice</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> parser.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">parseSlice</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(domElement);</span></span></code></pre></div><h2 id="constructors" tabindex="-1">Constructors <a class="header-anchor" href="#constructors" aria-label="Permalink to “Constructors”">​</a></h2><h3 id="constructor" tabindex="-1">Constructor <a class="header-anchor" href="#constructor" aria-label="Permalink to “Constructor”">​</a></h3><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> DOMParser</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(schema, rules): DOMParser;</span></span></code></pre></div><p>Defined in: <a href="https://github.com/type-editor/type/blob/29c0b7ebbb68b1528c0edc5e9973c4538cccdb64/packages/model/src/dom-parser/DOMParser.ts#L117" target="_blank" rel="noreferrer">packages/model/src/dom-parser/DOMParser.ts:117</a></p><p>Create a parser that targets the given schema, using the given parsing rules.</p><p>The constructor categorizes rules into tag and style rules, builds index maps for efficient rule lookup during parsing, and determines whether list normalization is needed based on the schema&#39;s content model.</p><h4 id="parameters" tabindex="-1">Parameters <a class="header-anchor" href="#parameters" aria-label="Permalink to “Parameters”">​</a></h4><table tabindex="0"><thead><tr><th>Parameter</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>schema</code></td><td><a href="./../../../schema/Schema/classes/Schema.html"><code>Schema</code></a></td><td>The schema into which the parser parses. Defines the document structure and which node and mark types are available.</td></tr><tr><td><code>rules</code></td><td>readonly <a href="./../../../types/dom-parser/ParseRule/type-aliases/ParseRule.html"><code>ParseRule</code></a>[]</td><td>The set of <a href="#model-parserule">parse rules</a> that the parser uses, in order of precedence. Can include both tag-based rules (matching DOM elements) and style-based rules (matching CSS properties). Rules are processed in the order provided, with earlier rules taking precedence.</td></tr></tbody></table><h4 id="returns" tabindex="-1">Returns <a class="header-anchor" href="#returns" aria-label="Permalink to “Returns”">​</a></h4><p><code>DOMParser</code></p><h2 id="accessors" tabindex="-1">Accessors <a class="header-anchor" href="#accessors" aria-label="Permalink to “Accessors”">​</a></h2><h3 id="matchedstyles" tabindex="-1">matchedStyles <a class="header-anchor" href="#matchedstyles" aria-label="Permalink to “matchedStyles”">​</a></h3><h4 id="get-signature" tabindex="-1">Get Signature <a class="header-anchor" href="#get-signature" aria-label="Permalink to “Get Signature”">​</a></h4><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">get </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">matchedStyles</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): readonly string[];</span></span></code></pre></div><p>Defined in: <a href="https://github.com/type-editor/type/blob/29c0b7ebbb68b1528c0edc5e9973c4538cccdb64/packages/model/src/dom-parser/DOMParser.ts#L140" target="_blank" rel="noreferrer">packages/model/src/dom-parser/DOMParser.ts:140</a></p><p>Get the list of CSS property names that have associated style parse rules.</p><p>This is used by the parser to optimize style matching by only checking CSS properties that have relevant rules defined.</p><h5 id="returns-1" tabindex="-1">Returns <a class="header-anchor" href="#returns-1" aria-label="Permalink to “Returns”">​</a></h5><p>readonly <code>string</code>[]</p><p>A readonly array of CSS property names (e.g., [&quot;font-weight&quot;, &quot;color&quot;]).</p><hr><h3 id="normalizelists" tabindex="-1">normalizeLists <a class="header-anchor" href="#normalizelists" aria-label="Permalink to “normalizeLists”">​</a></h3><h4 id="get-signature-1" tabindex="-1">Get Signature <a class="header-anchor" href="#get-signature-1" aria-label="Permalink to “Get Signature”">​</a></h4><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">get </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">normalizeLists</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): boolean;</span></span></code></pre></div><p>Defined in: <a href="https://github.com/type-editor/type/blob/29c0b7ebbb68b1528c0edc5e9973c4538cccdb64/packages/model/src/dom-parser/DOMParser.ts#L152" target="_blank" rel="noreferrer">packages/model/src/dom-parser/DOMParser.ts:152</a></p><p>Get whether list normalization should be performed during parsing.</p><p>List normalization is needed when the schema doesn&#39;t allow list nodes to directly contain themselves (i.e., nested lists must be wrapped in list items).</p><h5 id="returns-2" tabindex="-1">Returns <a class="header-anchor" href="#returns-2" aria-label="Permalink to “Returns”">​</a></h5><p><code>boolean</code></p><p>True if list normalization should be performed, false otherwise.</p><hr><h3 id="schema" tabindex="-1">schema <a class="header-anchor" href="#schema" aria-label="Permalink to “schema”">​</a></h3><h4 id="get-signature-2" tabindex="-1">Get Signature <a class="header-anchor" href="#get-signature-2" aria-label="Permalink to “Get Signature”">​</a></h4><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">get </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">schema</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(): Schema;</span></span></code></pre></div><p>Defined in: <a href="https://github.com/type-editor/type/blob/29c0b7ebbb68b1528c0edc5e9973c4538cccdb64/packages/model/src/dom-parser/DOMParser.ts#L161" target="_blank" rel="noreferrer">packages/model/src/dom-parser/DOMParser.ts:161</a></p><p>Get the ProseMirror schema this parser targets.</p><h5 id="returns-3" tabindex="-1">Returns <a class="header-anchor" href="#returns-3" aria-label="Permalink to “Returns”">​</a></h5><p><a href="./../../../schema/Schema/classes/Schema.html"><code>Schema</code></a></p><p>The schema that defines the document structure for this parser.</p><h2 id="methods" tabindex="-1">Methods <a class="header-anchor" href="#methods" aria-label="Permalink to “Methods”">​</a></h2><h3 id="matchstyle" tabindex="-1">matchStyle() <a class="header-anchor" href="#matchstyle" aria-label="Permalink to “matchStyle()”">​</a></h3><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">matchStyle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   prop,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   value,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   context,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   after</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> StyleParseRule;</span></span></code></pre></div><p>Defined in: <a href="https://github.com/type-editor/type/blob/29c0b7ebbb68b1528c0edc5e9973c4538cccdb64/packages/model/src/dom-parser/DOMParser.ts#L404" target="_blank" rel="noreferrer">packages/model/src/dom-parser/DOMParser.ts:404</a></p><p>Find the first matching style parse rule for the given CSS property and value.</p><p>This method iterates through the parser&#39;s style rules and returns the first rule that matches the given property name and value. Style rules can match either just a property name (e.g., &quot;font-weight&quot;) or a property-value pair (e.g., &quot;font-weight=bold&quot;). If a rule has a getAttrs function, it&#39;s called with the value to compute or validate attributes.</p><h4 id="parameters-1" tabindex="-1">Parameters <a class="header-anchor" href="#parameters-1" aria-label="Permalink to “Parameters”">​</a></h4><table tabindex="0"><thead><tr><th>Parameter</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>prop</code></td><td><code>string</code></td><td>The CSS property name to match (e.g., &quot;font-weight&quot;, &quot;color&quot;, &quot;text-decoration&quot;). Must exactly match the property name portion of the style rule.</td></tr><tr><td><code>value</code></td><td><code>string</code></td><td>The CSS property value to match (e.g., &quot;bold&quot;, &quot;#ff0000&quot;, &quot;underline&quot;). This is checked against style rules that specify a value (property=value format).</td></tr><tr><td><code>context</code></td><td><a href="./../../../types/dom-parser/DOMParseContext/interfaces/DOMParseContext.html"><code>DOMParseContext</code></a></td><td>The current parsing context, used to check context restrictions defined in the rules.</td></tr><tr><td><code>after?</code></td><td><a href="./../../../types/dom-parser/StyleParseRule/interfaces/StyleParseRule.html"><code>StyleParseRule</code></a></td><td>Optional rule to start searching after. Used when iterating through multiple matching rules for the same property-value pair. If provided, the search starts immediately after this rule in the rules array.</td></tr></tbody></table><h4 id="returns-4" tabindex="-1">Returns <a class="header-anchor" href="#returns-4" aria-label="Permalink to “Returns”">​</a></h4><p><a href="./../../../types/dom-parser/StyleParseRule/interfaces/StyleParseRule.html"><code>StyleParseRule</code></a></p><p>The first matching style parse rule with its attrs property potentially modified by getAttrs, or undefined if no matching rule is found.</p><h4 id="remarks" tabindex="-1">Remarks <a class="header-anchor" href="#remarks" aria-label="Permalink to “Remarks”">​</a></h4><p><strong>Side Effect Warning</strong>: This method may mutate the returned rule&#39;s attrs property when getAttrs is defined. This is intentional and expected by the parsing context.</p><h4 id="example-1" tabindex="-1">Example <a class="header-anchor" href="#example-1" aria-label="Permalink to “Example”">​</a></h4><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Match a simple property rule: {style: &quot;font-weight&quot;}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> rule1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> parser.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">matchStyle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;font-weight&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;bold&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, context);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Match a property-value rule: {style: &quot;font-weight=bold&quot;}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> rule2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> parser.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">matchStyle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;font-weight&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;bold&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, context);</span></span></code></pre></div><hr><h3 id="matchtag" tabindex="-1">matchTag() <a class="header-anchor" href="#matchtag" aria-label="Permalink to “matchTag()”">​</a></h3><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">matchTag</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   dom,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   context,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   after</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> TagParseRule;</span></span></code></pre></div><p>Defined in: <a href="https://github.com/type-editor/type/blob/29c0b7ebbb68b1528c0edc5e9973c4538cccdb64/packages/model/src/dom-parser/DOMParser.ts#L343" target="_blank" rel="noreferrer">packages/model/src/dom-parser/DOMParser.ts:343</a></p><p>Find the first matching tag parse rule for the given DOM element.</p><p>This method iterates through the parser&#39;s tag rules and returns the first rule that matches the given element&#39;s tag selector, namespace, and parsing context. If a rule has a getAttrs function, it&#39;s called to compute or validate attributes, and the rule is skipped if it returns false.</p><h4 id="parameters-2" tabindex="-1">Parameters <a class="header-anchor" href="#parameters-2" aria-label="Permalink to “Parameters”">​</a></h4><table tabindex="0"><thead><tr><th>Parameter</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>dom</code></td><td><code>Node</code></td><td>The DOM node to match against tag rules. Will be cast to Element for selector matching and to HTMLElement for getAttrs calls.</td></tr><tr><td><code>context</code></td><td><a href="./../../../types/dom-parser/DOMParseContext/interfaces/DOMParseContext.html"><code>DOMParseContext</code></a></td><td>The current parsing context, used to check context restrictions defined in the rules (e.g., &quot;paragraph/&quot; or &quot;blockquote/paragraph/&quot;).</td></tr><tr><td><code>after?</code></td><td><a href="./../../../types/dom-parser/TagParseRule/interfaces/TagParseRule.html"><code>TagParseRule</code></a></td><td>Optional rule to start searching after. Used when iterating through multiple matching rules for the same element. If provided, the search starts immediately after this rule in the rules array.</td></tr></tbody></table><h4 id="returns-5" tabindex="-1">Returns <a class="header-anchor" href="#returns-5" aria-label="Permalink to “Returns”">​</a></h4><p><a href="./../../../types/dom-parser/TagParseRule/interfaces/TagParseRule.html"><code>TagParseRule</code></a></p><p>The first matching tag parse rule with its attrs property potentially modified by getAttrs, or undefined if no matching rule is found.</p><h4 id="remarks-1" tabindex="-1">Remarks <a class="header-anchor" href="#remarks-1" aria-label="Permalink to “Remarks”">​</a></h4><p><strong>Side Effect Warning</strong>: This method may mutate the returned rule&#39;s attrs property when getAttrs is defined. This is intentional and expected by the parsing context, which relies on the attrs being set on the rule object.</p><hr><h3 id="parse" tabindex="-1">parse() <a class="header-anchor" href="#parse" aria-label="Permalink to “parse()”">​</a></h3><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">parse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(dom, options</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Node;</span></span></code></pre></div><p>Defined in: <a href="https://github.com/type-editor/type/blob/29c0b7ebbb68b1528c0edc5e9973c4538cccdb64/packages/model/src/dom-parser/DOMParser.ts#L465" target="_blank" rel="noreferrer">packages/model/src/dom-parser/DOMParser.ts:465</a></p><p>Parse a document from the content of a DOM node.</p><p>This method creates a complete ProseMirror document by parsing the given DOM node and its children according to the parser&#39;s rules. The resulting document will conform to the parser&#39;s schema constraints.</p><h4 id="parameters-3" tabindex="-1">Parameters <a class="header-anchor" href="#parameters-3" aria-label="Permalink to “Parameters”">​</a></h4><table tabindex="0"><thead><tr><th>Parameter</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>dom</code></td><td><code>string</code> | <code>Node</code> | <code>Element</code></td><td>The DOM node whose content should be parsed. Can be any DOM node type (Element, Text, DocumentFragment, etc.). The node&#39;s children will be recursively parsed. Can also be a HTML string.</td></tr><tr><td><code>options</code></td><td><a href="./../../../types/dom-parser/ParseOptions/interfaces/ParseOptions.html"><code>ParseOptions</code></a></td><td>Optional parsing configuration object: - <code>preserveWhitespace</code>: Controls whitespace handling (boolean or &quot;full&quot;) - <code>findPositions</code>: Array of DOM nodes to track positions for - <code>from</code>: Starting index in the DOM node&#39;s children - <code>to</code>: Ending index in the DOM node&#39;s children - <code>topNode</code>: The node type to use as document root - <code>topMatch</code>: Content match to use for the document - <code>context</code>: Additional parsing context</td></tr></tbody></table><h4 id="returns-6" tabindex="-1">Returns <a class="header-anchor" href="#returns-6" aria-label="Permalink to “Returns”">​</a></h4><p><a href="./../../../elements/Node/classes/Node.html"><code>Node</code></a></p><p>A ProseMirror node representing the parsed document. This will be a complete, valid node according to the schema&#39;s constraints.</p><h4 id="example-2" tabindex="-1">Example <a class="header-anchor" href="#example-2" aria-label="Permalink to “Example”">​</a></h4><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> parser</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> DOMParser.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fromSchema</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(mySchema);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Parse an entire document</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> doc</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> parser.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">parse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(document.body);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Parse with options</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> doc2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> parser.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">parse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(domElement, {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  preserveWhitespace: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  from: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  to: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><hr><h3 id="parseslice" tabindex="-1">parseSlice() <a class="header-anchor" href="#parseslice" aria-label="Permalink to “parseSlice()”">​</a></h3><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">parseSlice</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(dom, options</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Slice;</span></span></code></pre></div><p>Defined in: <a href="https://github.com/type-editor/type/blob/29c0b7ebbb68b1528c0edc5e9973c4538cccdb64/packages/model/src/dom-parser/DOMParser.ts#L521" target="_blank" rel="noreferrer">packages/model/src/dom-parser/DOMParser.ts:521</a></p><p>Parses the content of the given DOM node, like <a href="#model-domparser-parse"><code>parse</code></a>, and takes the same set of options. But unlike that method, which produces a whole node, this one returns a slice that is open at the sides, meaning that the schema constraints aren&#39;t applied to the start of nodes to the left of the input and the end of nodes at the end.</p><p>This is particularly useful for parsing content that will be inserted into an existing document, such as clipboard content or drag-and-drop data, where you want to preserve the structure without forcing it to be a complete document.</p><h4 id="parameters-4" tabindex="-1">Parameters <a class="header-anchor" href="#parameters-4" aria-label="Permalink to “Parameters”">​</a></h4><table tabindex="0"><thead><tr><th>Parameter</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>dom</code></td><td><code>Node</code></td><td>The DOM node whose content should be parsed. Can be any DOM node type. The content will be parsed more leniently than in <code>parse()</code>, allowing partial structures.</td></tr><tr><td><code>options</code></td><td><a href="./../../../types/dom-parser/ParseOptions/interfaces/ParseOptions.html"><code>ParseOptions</code></a></td><td>Optional parsing configuration object (same as <a href="#parse">parse</a>): - <code>preserveWhitespace</code>: Controls whitespace handling - <code>findPositions</code>: Array of DOM nodes to track positions for - <code>from</code>: Starting index in the DOM node&#39;s children - <code>to</code>: Ending index in the DOM node&#39;s children - <code>topNode</code>: The node type to use as root - <code>topMatch</code>: Content match to use - <code>context</code>: Additional parsing context</td></tr></tbody></table><h4 id="returns-7" tabindex="-1">Returns <a class="header-anchor" href="#returns-7" aria-label="Permalink to “Returns”">​</a></h4><p><a href="./../../../elements/Slice/classes/Slice.html"><code>Slice</code></a></p><p>A slice representing the parsed content with open sides. The slice&#39;s <code>openStart</code> and <code>openEnd</code> properties indicate how many parent nodes are &quot;open&quot; at the start and end, allowing the content to be inserted flexibly into different contexts.</p><h4 id="example-3" tabindex="-1">Example <a class="header-anchor" href="#example-3" aria-label="Permalink to “Example”">​</a></h4><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> parser</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> DOMParser.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fromSchema</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(mySchema);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Parse clipboard content as a slice</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> slice</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> parser.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">parseSlice</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(clipboardData);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Insert the slice into a document at a position</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> tr</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> state.tr.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">replaceRange</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(from, to, slice);</span></span></code></pre></div><hr><h3 id="fromschema" tabindex="-1">fromSchema() <a class="header-anchor" href="#fromschema" aria-label="Permalink to “fromSchema()”">​</a></h3><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">static </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fromSchema</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(schema): DOMParser;</span></span></code></pre></div><p>Defined in: <a href="https://github.com/type-editor/type/blob/29c0b7ebbb68b1528c0edc5e9973c4538cccdb64/packages/model/src/dom-parser/DOMParser.ts#L199" target="_blank" rel="noreferrer">packages/model/src/dom-parser/DOMParser.ts:199</a></p><p>Construct a DOM parser using the parsing rules listed in a schema&#39;s <a href="#model-nodespec-parsedom">node specs</a> and <a href="#model-markspec-parsedom">mark specs</a>, reordered by <a href="#model-genericparserule-priority">priority</a>.</p><p>The parser is cached on the schema object for reuse, so subsequent calls with the same schema will return the same parser instance.</p><p>This is the recommended way to create a parser, as it automatically extracts all parse rules from the schema&#39;s node and mark specifications.</p><h4 id="parameters-5" tabindex="-1">Parameters <a class="header-anchor" href="#parameters-5" aria-label="Permalink to “Parameters”">​</a></h4><table tabindex="0"><thead><tr><th>Parameter</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>schema</code></td><td><a href="./../../../schema/Schema/classes/Schema.html"><code>Schema</code></a></td><td>The schema to extract parsing rules from. All parseDOM rules defined in the schema&#39;s node and mark specifications will be collected and sorted by priority.</td></tr></tbody></table><h4 id="returns-8" tabindex="-1">Returns <a class="header-anchor" href="#returns-8" aria-label="Permalink to “Returns”">​</a></h4><p><code>DOMParser</code></p><p>A DOM parser instance configured for the given schema. Returns the cached instance if one exists, otherwise creates and caches a new one.</p><h4 id="example-4" tabindex="-1">Example <a class="header-anchor" href="#example-4" aria-label="Permalink to “Example”">​</a></h4><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> schema</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Schema</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  nodes: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    doc: { content: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;block+&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    paragraph: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      parseDOM: [{ tag: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;p&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }],</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      toDOM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;p&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> parser</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> DOMParser.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fromSchema</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(schema);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> doc</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> parser.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">parse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">querySelector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;#content&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span></code></pre></div><hr><h3 id="schemarules" tabindex="-1">schemaRules() <a class="header-anchor" href="#schemarules" aria-label="Permalink to “schemaRules()”">​</a></h3><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">static </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">schemaRules</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(schema): ParseRule[];</span></span></code></pre></div><p>Defined in: <a href="https://github.com/type-editor/type/blob/29c0b7ebbb68b1528c0edc5e9973c4538cccdb64/packages/model/src/dom-parser/DOMParser.ts#L235" target="_blank" rel="noreferrer">packages/model/src/dom-parser/DOMParser.ts:235</a></p><p>Extract and combine all parsing rules from a schema&#39;s node and mark specifications, sorted by priority (higher priority rules come first).</p><p>This method iterates through all mark types and node types in the schema, collecting their parseDOM rules. Each rule is copied to avoid mutation of the original schema specifications. If a rule doesn&#39;t specify which mark or node it creates, that information is filled in based on the type it came from.</p><p>The resulting array is sorted by priority (default 50), with higher priority rules appearing first. This ensures that more specific rules are tried before more general ones during parsing.</p><h4 id="parameters-6" tabindex="-1">Parameters <a class="header-anchor" href="#parameters-6" aria-label="Permalink to “Parameters”">​</a></h4><table tabindex="0"><thead><tr><th>Parameter</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>schema</code></td><td><a href="./../../../schema/Schema/classes/Schema.html"><code>Schema</code></a></td><td>The schema to extract rules from. Must contain node and mark specifications with parseDOM arrays.</td></tr></tbody></table><h4 id="returns-9" tabindex="-1">Returns <a class="header-anchor" href="#returns-9" aria-label="Permalink to “Returns”">​</a></h4><p><a href="./../../../types/dom-parser/ParseRule/type-aliases/ParseRule.html"><code>ParseRule</code></a>[]</p><p>An array of parse rules sorted by priority in descending order (highest priority first). Each rule is a copy of the original with mark/node names filled in where needed.</p><h4 id="example-5" tabindex="-1">Example <a class="header-anchor" href="#example-5" aria-label="Permalink to “Example”">​</a></h4><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> schema</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Schema</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  nodes: { doc: {}, paragraph: { parseDOM: [{ tag: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;p&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }] } },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  marks: { strong: { parseDOM: [{ tag: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;strong&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }] } },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> rules</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> DOMParser.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">schemaRules</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(schema);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Returns array with strong and paragraph rules, sorted by priority</span></span></code></pre></div>`,130)])])}const g=e(r,[["render",n]]);export{k as __pageData,g as default};
